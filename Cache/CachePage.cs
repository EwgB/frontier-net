namespace FrontierSharp.Cache {
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;

    using OpenTK;
    using OpenTK.Graphics.OpenGL;

    using Common.Game;
    using Common.Grid;
    using Common.Property;
    using Common.Region;
    using Common.Util;
    using Common.World;

    /// <summary>
    ///   This class is used to generate and cache cachePages of world texture data.
    ///   The cachePages are generated by combining the topographical data(elevations)
    ///   with the region data(modifying the evevation to make the different land
    ///   formations) and then is used to generate the table of surface data, which
    ///   describes how to paint the textures for the given area.
    /// </summary>
    internal sealed class CachePage : ICachePage {

        private enum Stages {
            Begin,
            Position,
            Normal,
            Surface1,
            Surface2,
            Color,
            Trees,
            Save,
            Done
        }

        private struct PageCell {
            public SurfaceTypes Surface;
            public float WaterLevel;
            public float Elevation;
            public float Detail;
            public Color3 Color;
            public Vector3 Normal;
            public ushort TreeId;
        }

        [Serializable]
        private class CachePageData {
            public readonly PageCell[,] Cells = new PageCell[PAGE_SIZE, PAGE_SIZE];
        }
 
        #region Constants

        public const int PAGE_SIZE = 128;
        private const int TREE_SPACING = 8; //Power of 2, how far apart trees should be. (Roughly)
        private const int TREE_MAP = (PAGE_SIZE / TREE_SPACING);

        private static readonly IFormatter Formatter = new BinaryFormatter();
        private static readonly TimeSpan ExpireInterval = TimeSpan.FromMilliseconds(30000);
        private static readonly TimeSpan SaveInterval = TimeSpan.FromMilliseconds(1000);

        #endregion


        #region Modules

        private IGame Game { get; }
        private IProperties Properties { get; }
        private IWorld World { get; }

        #endregion


        #region Members and properties

        private CachePageData data = new CachePageData();

        private Coord origin;
        private Coord walk;
        private TimeSpan lastTouched;
        private Stages stage = Stages.Begin;
        private TimeSpan saveCooldown = new TimeSpan(0);
        private BoundingBox boundingBox = new BoundingBox();

        public bool IsExpired => (this.lastTouched + ExpireInterval) < this.Game.GameProperties.GameTime;
        private string GetPageFileName(Coord p) => Path.Combine(this.Game.GameDirectory, $"cache{p.X}-{p.Y}.pag");

        #endregion


        public CachePage(IGame game, IProperties properties, IWorld world) {
            this.Game = game;
            this.Properties = properties;
            this.World = world;
        }

        //    bool Ready();


        #region Getters

        public float GetElevation(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).Elevation;
        }

        public float GetDetail(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).Detail;
        }

        public ushort GetTree(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).TreeId;
        }

        public Vector3 GetPosition(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return new Vector3(
                x + this.origin.X * PAGE_SIZE,
                y + this.origin.Y * PAGE_SIZE,
                GetPageCell(x, y).Elevation);
        }

        public Vector3 GetNormal(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).Normal;
        }

        public Color3 GetColor(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).Color;
        }

        public SurfaceTypes GetSurface(int x, int y) {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).Surface;
        }

        public bool IsReady() {
            this.lastTouched = this.Game.GameProperties.GameTime;
            return this.stage == Stages.Done;
        }

        #endregion


        #region Public methods

        public void Render() {
            GL.Disable(EnableCap.Texture2D);
            GL.Disable(EnableCap.Lighting);
            var elapsed = this.Game.GameProperties.GameTime - this.lastTouched;
            var n = MathHelper.Clamp(elapsed.TotalMilliseconds / ExpireInterval.TotalMilliseconds, 0, 1);
            GL.Color3(n, 1 - n, 0);
            this.boundingBox.Render();
        }

        public void Build(double stopAt) {
            while (this.stage != Stages.Done && this.Game.GameProperties.GameTime.TotalMilliseconds < stopAt) {
                switch (this.stage) {
                case Stages.Begin:
                    this.stage++;
                    break;
                case Stages.Position:
                    DoPosition();
                    break;
                case Stages.Normal:
                    DoNormal();
                    break;
                case Stages.Surface1:
                case Stages.Surface2:
                    DoSurface();
                    break;
                case Stages.Color:
                    DoColor();
                    break;
                case Stages.Trees:
                    DoTrees();
                    break;
                case Stages.Save:
                    Save();
                    return;
                }
            }
        }

        public void Save() {
            if (!this.Properties.GetProperty<bool>("cache.active").Value) {
                this.stage++;
                return;
            }

            var now = this.Game.GameProperties.GameTime;
            if (now < this.saveCooldown || this.stage < Stages.Save)
                return;
            if (this.stage == Stages.Save)
                this.stage++;
            using (var stream = File.Open(GetPageFileName(this.origin), FileMode.Create))
                Formatter.Serialize(stream, this.data);
            this.saveCooldown = now + SaveInterval;
        }

        public void Load(int originX, int originY) {
            this.origin = new Coord(originX, originY);
            this.stage = Stages.Begin;
            this.boundingBox.Clear();

            var path = GetPageFileName(this.origin);
            if (File.Exists(path))
                using (var stream = File.Open(path, FileMode.Open)) {
                    this.data = (CachePageData) Formatter.Deserialize(stream);
                }

            this.walk = new Coord();
            this.lastTouched = this.Game.GameProperties.GameTime;
        }

        #endregion


        #region Private methods

        private PageCell GetPageCell(int x, int y) => this.data.Cells[x % PAGE_SIZE, y % PAGE_SIZE];

        private void DoPosition() {
            var worldX = (this.origin.X * PAGE_SIZE + this.walk.X);
            var worldY = (this.origin.Y * PAGE_SIZE + this.walk.Y);
            var c = this.World.GetCell(worldX, worldY);
            this.data.Cells[this.walk.X, this.walk.Y].Elevation = c.Elevation;
            this.data.Cells[this.walk.X, this.walk.Y].Detail = c.Detail;
            this.data.Cells[this.walk.X, this.walk.Y].WaterLevel = c.WaterLevel;
            this.data.Cells[this.walk.X, this.walk.Y].TreeId = 0;
            this.boundingBox.ContainPoint(GetPosition(worldX, worldY));
            this.walk = this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoColor() {
            var worldX = (this.origin.X * PAGE_SIZE + this.walk.X);
            var worldY = (this.origin.Y * PAGE_SIZE + this.walk.Y);
            var cell = this.data.Cells[this.walk.X, this.walk.Y];
            if (cell.Surface == SurfaceTypes.Grass || cell.Surface == SurfaceTypes.GrassEdge)
                cell.Color = this.World.GetColor(worldX, worldY, SurfaceColor.Grass);
            else if (cell.Surface == SurfaceTypes.Dirt ||
                     cell.Surface == SurfaceTypes.DirtDark ||
                     cell.Surface == SurfaceTypes.Forest)
                cell.Color = this.World.GetColor(worldX, worldY, SurfaceColor.Dirt);
            else if (cell.Surface == SurfaceTypes.Sand || cell.Surface == SurfaceTypes.SandDark)
                cell.Color = this.World.GetColor(worldX, worldY, SurfaceColor.Sand);
            else if (cell.Surface == SurfaceTypes.Snow)
                cell.Color = Color3.White;
            else
                cell.Color = this.World.GetColor(worldX, worldY, SurfaceColor.Rock);

            this.walk = this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoNormal() {
            var worldX = (float) (this.origin.X + this.walk.X);
            var worldY = (float) (this.origin.Y + this.walk.Y);

            Vector3 normalX;
            if (this.walk.X < 1 || this.walk.X >= PAGE_SIZE - 1)
                normalX = new Vector3(-1, 0, 0);
            else
                normalX = new Vector3(worldX - 1, worldY, this.data.Cells[this.walk.X - 1, this.walk.Y].Elevation) -
                          new Vector3(worldX + 1, worldY, this.data.Cells[this.walk.X + 1, this.walk.Y].Elevation);

            Vector3 normalY;
            if (this.walk.Y < 1 || this.walk.Y >= PAGE_SIZE - 1)
                normalY = new Vector3(0, -1, 0);
            else
                normalY = new Vector3(worldX, worldY - 1, this.data.Cells[this.walk.X, this.walk.Y - 1].Elevation) -
                          new Vector3(worldX, worldY, this.data.Cells[this.walk.X, this.walk.Y + 1].Elevation);

            var normal = Vector3.Cross(normalX, normalY);
            normal.Z *= WorldUtils.NORMAL_SCALING;
            normal.Normalize();
            this.data.Cells[this.walk.X, this.walk.Y].Normal = normal;

            this.walk = this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoTrees() {
            var region = this.World.GetRegionFromPosition(
                this.origin.X * PAGE_SIZE + this.walk.X,
                this.origin.Y * PAGE_SIZE + this.walk.Y);

            var tree = this.World.GetTree(region.TreeType);
            var best = tree.GrowsHigh ? -99999.9f : 99999.9f;

            var plant = new Coord();
            var valid = false;
            for (var x = 0; x < TREE_SPACING - 2; x++) {
                for (var y = 0; y < TREE_SPACING - 2; y++) {
                    var cell = this.data.Cells[this.walk.X * TREE_SPACING + x, this.walk.Y * TREE_SPACING + y];
                    if (cell.Surface != SurfaceTypes.Grass && cell.Surface != SurfaceTypes.Snow && cell.Surface != SurfaceTypes.Forest)
                        continue;
                    //Don't spawn trees that might touch water. Looks odd.
                    if (cell.Elevation < cell.WaterLevel + 1.2f)
                        continue;
                    if (tree.GrowsHigh && (cell.Detail + region.TreeThreshold) > 1 && cell.Elevation > best) {
                        plant = new Coord(
                            this.walk.X * TREE_SPACING + x,
                            this.walk.Y * TREE_SPACING + y);
                        best = cell.Elevation;
                        valid = true;
                    }

                    if (!tree.GrowsHigh && (cell.Detail - region.TreeThreshold) < 0 && cell.Elevation < best) {
                        plant = new Coord(
                            this.walk.X * TREE_SPACING + x,
                            this.walk.Y * TREE_SPACING + y);
                        best = cell.Elevation;
                        valid = true;
                    }
                }
            }

            if (valid) {
                this.data.Cells[plant.X, plant.Y].TreeId = region.TreeType;
            }

            this.walk = this.walk.Walk(TREE_MAP, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoSurface() {
            var worldpos = new Coord(
                this.origin.X * PAGE_SIZE + this.walk.X,
                this.origin.Y * PAGE_SIZE + this.walk.Y);
            var region = this.World.GetRegionFromPosition(worldpos.X, worldpos.Y);
            PageCell c = this.data.Cells[this.walk.X, this.walk.Y];

            if (this.stage == Stages.Surface1) {
                //Get the elevation of our neighbors
                float low;
                var high = low = c.Elevation;
                for (var xx = -2; xx <= 2; xx++) {
                    var neighborX = this.walk.X + xx;
                    if (neighborX < 0 || neighborX >= PAGE_SIZE)
                        continue;
                    for (var yy = -2; yy <= 2; yy++) {
                        var neighborY = this.walk.Y + yy;
                        if (neighborY < 0 || neighborY >= PAGE_SIZE)
                            continue;
                        high = Math.Max(high, this.data.Cells[neighborX, neighborY].Elevation);
                        low = Math.Min(low, this.data.Cells[neighborX, neighborY].Elevation);
                    }
                }

                var delta = high - low;
                //Default surface. If the climate can support life, default to grass.
                if (region.Temperature > 0.1f && region.Moisture > 0.1f)
                    c.Surface = SurfaceTypes.Grass;
                else //Too cold or dry
                    c.Surface = SurfaceTypes.Rock;
                if (region.Climate == ClimateType.Desert)
                    c.Surface = SurfaceTypes.Sand;
                //Sand is only for coastal regions
                if (low <= 2 && (region.Climate == ClimateType.Coast))
                    c.Surface = SurfaceTypes.Sand;
                if (low <= 2 && (region.Climate == ClimateType.Ocean))
                    c.Surface = SurfaceTypes.Sand;
                //Forests are for... forests?
                if (c.Detail < 0.75f && c.Detail > 0.25f && (region.Climate == ClimateType.Forest))
                    c.Surface = SurfaceTypes.Forest;
                if (delta >= region.Moisture * 6)
                    c.Surface = SurfaceTypes.Dirt;
                if (low <= region.GeoWater && region.Climate != ClimateType.Swamp)
                    c.Surface = SurfaceTypes.Dirt;
                if (low <= region.GeoWater && region.Climate != ClimateType.Swamp)
                    c.Surface = SurfaceTypes.DirtDark;
                //The colder it is, the more surface becomes snow, beginning at the lowest points.
                if (region.Temperature < WorldUtils.FREEZING) {
                    var fade = region.Temperature / WorldUtils.FREEZING;
                    if ((1 - c.Detail) > fade)
                        c.Surface = SurfaceTypes.Snow;
                }

                if (low <= 2.5f && (region.Climate == ClimateType.Ocean))
                    c.Surface = SurfaceTypes.Sand;
                if (low <= 2.5f && (region.Climate == ClimateType.Coast))
                    c.Surface = SurfaceTypes.Sand;
                //dirt touched by water is dark
                if (region.Climate != ClimateType.Swamp) {
                    if (c.Surface == SurfaceTypes.Sand && low <= 0)
                        c.Surface = SurfaceTypes.SandDark;
                    if (low <= c.WaterLevel)
                        c.Surface = SurfaceTypes.DirtDark;
                }

                if (delta > 4 && region.Temperature > 0)
                    c.Surface = SurfaceTypes.Rock;
                if ((region.Climate == ClimateType.Desert) && c.Surface != SurfaceTypes.Rock)
                    c.Surface = SurfaceTypes.Sand;
            } else {
                if (c.Surface == SurfaceTypes.Grass && this.walk.X > 0 && this.walk.X < PAGE_SIZE - 1 && this.walk.Y > 0 &&
                    this.walk.Y < PAGE_SIZE - 1) {
                    var allGrass = true;
                    for (var xx = -1; xx <= 1; xx++) {
                        if (!allGrass)
                            break;
                        for (var yy = -1; yy <= 1; yy++) {
                            if (this.data.Cells[this.walk.X + xx, this.walk.Y + yy].Surface != SurfaceTypes.Grass &&
                                this.data.Cells[this.walk.X + xx, this.walk.Y + yy].Surface != SurfaceTypes.GrassEdge) {
                                allGrass = false;
                                break;
                            }
                        }
                    }

                    if (!allGrass)
                        c.Surface = SurfaceTypes.GrassEdge;
                }
            }

            this.walk = this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        #endregion
    }
}
