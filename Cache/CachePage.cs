namespace FrontierSharp.Cache {
    using System;

    using OpenTK;
    using OpenTK.Graphics.OpenGL;

    using Common.Game;
    using Common.Grid;
    using Common.Region;
    using Common.Util;
    using Common.World;

    /// <summary>
    ///   This class is used to generate and cache cachePages of world texture data.
    ///   The cachePages are generated by combining the topographical data(elevations)
    ///   with the region data(modifying the evevation to make the different land
    ///   formations) and then is used to generate the table of surface data, which
    ///   describes how to paint the textures for the given area.
    /// </summary>
    [Serializable]
    internal sealed class CachePage {

        internal enum Stages {
            Begin,
            Position,
            Normal,
            Surface1,
            Surface2,
            Color,
            Trees,
            Save,
            Done
        }

        private struct PageCell {
            internal SurfaceTypes surface;
            internal float waterLevel;
            internal float elevation;
            internal float detail;
            internal Color3 color;
            internal Vector3 normal;
            internal ushort treeId;
        }


        #region Constants

        internal const int PAGE_SIZE = 128;
        private static readonly TimeSpan ExpireInterval = TimeSpan.FromMilliseconds(30000);
        private const int TREE_SPACING = 8; //Power of 2, how far apart trees should be. (Roughly)
        private const int TREE_MAP = (PAGE_SIZE / TREE_SPACING);

        #endregion


        internal CachePage(IGame game, IWorld world, CachePageFactory pageFactory) {
            this.Game = game;
            this.World = world;
            this.PageFactory = pageFactory;
        }


        #region Modules

        internal IGame Game { get; set; }
        internal IWorld World { get; set; }

        internal CachePageFactory PageFactory { get; set; }

        #endregion


        #region Members and properties

        [NonSerialized] private Coord origin = new Coord(0, 0);

        internal Coord Origin {
            get => this.origin;
            set => this.origin = value;
        }

        [NonSerialized] private TimeSpan lastTouched;

        internal TimeSpan LastTouched {
            get => this.lastTouched;
            set => this.lastTouched = value;
        }

        [NonSerialized] private Stages stage = Stages.Begin;

        internal Stages Stage {
            get => this.stage;
            set => this.stage = value;
        }

        [NonSerialized] private TimeSpan saveCooldown = new TimeSpan(0);

        internal TimeSpan SaveCooldown {
            get => this.saveCooldown;
            set => this.saveCooldown = value;
        }

        [NonSerialized] private Coord walk = new Coord(0, 0);
        [NonSerialized] private BoundingBox boundingBox = new BoundingBox();

        private readonly PageCell[,] cells = new PageCell[PAGE_SIZE, PAGE_SIZE];

        internal bool IsExpired => (this.LastTouched + ExpireInterval) < this.Game.GameProperties.GameTime;

        #endregion



        //    bool Ready();


        #region Getters

        public float GetElevation(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).elevation;
        }

        public float GetDetail(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).detail;
        }

        public ushort GetTree(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).treeId;
        }

        public Vector3 GetPosition(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return new Vector3(
                x + this.Origin.X * PAGE_SIZE,
                y + this.Origin.Y * PAGE_SIZE,
                GetPageCell(x, y).elevation);
        }

        public Vector3 GetNormal(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).normal;
        }

        public Color3 GetColor(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).color;
        }

        public SurfaceTypes GetSurface(int x, int y) {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return GetPageCell(x, y).surface;
        }

        public bool IsReady() {
            this.LastTouched = this.Game.GameProperties.GameTime;
            return this.Stage == Stages.Done;
        }

        #endregion


        #region Public methods

        public void Render() {
            GL.Disable(EnableCap.Texture2D);
            GL.Disable(EnableCap.Lighting);
            var elapsed = this.Game.GameProperties.GameTime - this.LastTouched;
            var n = MathHelper.Clamp(elapsed.TotalMilliseconds / ExpireInterval.TotalMilliseconds, 0, 1);
            GL.Color3(n, 1 - n, 0);
            this.boundingBox.Render();
        }

        public void Build(double stopAt) {
            while (this.stage != Stages.Done && this.Game.GameProperties.GameTime.TotalMilliseconds < stopAt) {
                switch (this.stage) {
                case Stages.Begin:
                    this.stage++;
                    break;
                case Stages.Position:
                    DoPosition();
                    break;
                case Stages.Normal:
                    DoNormal();
                    break;
                case Stages.Surface1:
                case Stages.Surface2:
                    DoSurface();
                    break;
                case Stages.Color:
                    DoColor();
                    break;
                case Stages.Trees:
                    DoTrees();
                    break;
                case Stages.Save:
                    this.PageFactory.SaveCachePage(this);
                    return;
                }
            }
        }

        #endregion


        #region Private methods

        private PageCell GetPageCell(int x, int y) => this.cells[x % PAGE_SIZE, y % PAGE_SIZE];

        private void DoPosition() {
            var worldX = (this.origin.X * PAGE_SIZE + this.walk.X);
            var worldY = (this.origin.Y * PAGE_SIZE + this.walk.Y);
            var c = this.World.GetCell(worldX, worldY);
            this.cells[this.walk.X, this.walk.Y].elevation = c.elevation;
            this.cells[this.walk.X, this.walk.Y].detail = c.detail;
            this.cells[this.walk.X, this.walk.Y].waterLevel = c.waterLevel;
            this.cells[this.walk.X, this.walk.Y].treeId = 0;
            this.boundingBox.ContainPoint(GetPosition(worldX, worldY));
            this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoColor() {
            var worldX = (this.origin.X * PAGE_SIZE + this.walk.X);
            var worldY = (this.origin.Y * PAGE_SIZE + this.walk.Y);
            var cell = this.cells[this.walk.X, this.walk.Y];
            if (cell.surface == SurfaceTypes.Grass || cell.surface == SurfaceTypes.GrassEdge)
                cell.color = this.World.GetColor(worldX, worldY, SurfaceColors.Grass);
            else if (cell.surface == SurfaceTypes.Dirt ||
                     cell.surface == SurfaceTypes.DirtDark ||
                     cell.surface == SurfaceTypes.Forest)
                cell.color = this.World.GetColor(worldX, worldY, SurfaceColors.Dirt);
            else if (cell.surface == SurfaceTypes.Sand || cell.surface == SurfaceTypes.SandDark)
                cell.color = this.World.GetColor(worldX, worldY, SurfaceColors.Sand);
            else if (cell.surface == SurfaceTypes.Snow)
                cell.color = Color3.White;
            else
                cell.color = this.World.GetColor(worldX, worldY, SurfaceColors.Rock);

            this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoNormal() {
            var worldX = (float) (this.origin.X + this.walk.X);
            var worldY = (float) (this.origin.Y + this.walk.Y);

            Vector3 normalX;
            if (this.walk.X < 1 || this.walk.X >= PAGE_SIZE - 1)
                normalX = new Vector3(-1, 0, 0);
            else
                normalX = new Vector3(worldX - 1, worldY, this.cells[this.walk.X - 1, this.walk.Y].elevation) -
                          new Vector3(worldX + 1, worldY, this.cells[this.walk.X + 1, this.walk.Y].elevation);

            Vector3 normalY;
            if (this.walk.Y < 1 || this.walk.Y >= PAGE_SIZE - 1)
                normalY = new Vector3(0, -1, 0);
            else
                normalY = new Vector3(worldX, worldY - 1, this.cells[this.walk.X, this.walk.Y - 1].elevation) -
                          new Vector3(worldX, worldY, this.cells[this.walk.X, this.walk.Y + 1].elevation);

            var normal = Vector3.Cross(normalX, normalY);
            normal.Z *= WorldUtils.NORMAL_SCALING;
            normal.Normalize();
            this.cells[this.walk.X, this.walk.Y].normal = normal;

            this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoTrees() {
            PageCell c;
            Coord plant;
            float best;

            var worldpos = new Coord(
                this.origin.X * PAGE_SIZE + this.walk.X,
                this.origin.Y * PAGE_SIZE + this.walk.Y);
            IRegion region = this.World.GetRegionFromPosition(worldpos.X, worldpos.Y);
            var valid = false;

            CTree tree = WorldTree(region.TreeType);
            if (tree.GrowsHigh())
                best = -99999.9f;
            else
                best = 99999.9f;
            for (var x = 0; x < TREE_SPACING - 2; x++) {
                for (var y = 0; y < TREE_SPACING - 2; y++) {
                    c = this.cells[this.walk.X * TREE_SPACING + x, this.walk.Y * TREE_SPACING + y];
                    if (c.surface != SurfaceTypes.Grass && c.surface != SurfaceTypes.Snow && c.surface != SurfaceTypes.Forest)
                        continue;
                    //Don't spawn trees that might touch water.  Looks odd.
                    if (c.elevation < c.waterLevel + 1.2f)
                        continue;
                    if (tree.GrowsHigh() && (c.detail + region.TreeThreshold) > 1 && c.elevation > best) {
                        plant = new Coord(
                            this.walk.X * TREE_SPACING + x,
                            this.walk.Y * TREE_SPACING + y);
                        best = c.elevation;
                        valid = true;
                    }

                    if (!tree.GrowsHigh() && (c.detail - region.TreeThreshold) < 0 && c.elevation < best) {
                        plant = new Coord(
                            this.walk.X * TREE_SPACING + x,
                            this.walk.Y * TREE_SPACING + y);
                        best = c.elevation;
                        valid = true;
                    }
                }
            }

            if (valid) {
                c = this.cells[plant.X, plant.Y];
                c.treeId = region.TreeType;
            }

            this.walk.Walk(TREE_MAP, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        private void DoSurface() {
            var worldpos = new Coord(
                this.origin.X * PAGE_SIZE + this.walk.X,
                this.origin.Y * PAGE_SIZE + this.walk.Y);
            var region = this.World.GetRegionFromPosition(worldpos.X, worldpos.Y);
            PageCell c = this.cells[this.walk.X, this.walk.Y];

            if (this.stage == Stages.Surface1) {
                //Get the elevation of our neighbors
                float low;
                var high = low = c.elevation;
                for (var xx = -2; xx <= 2; xx++) {
                    var neighborX = this.walk.X + xx;
                    if (neighborX < 0 || neighborX >= PAGE_SIZE)
                        continue;
                    for (var yy = -2; yy <= 2; yy++) {
                        var neighborY = this.walk.Y + yy;
                        if (neighborY < 0 || neighborY >= PAGE_SIZE)
                            continue;
                        high = Math.Max(high, this.cells[neighborX, neighborY].elevation);
                        low = Math.Min(low, this.cells[neighborX, neighborY].elevation);
                    }
                }

                var delta = high - low;
                //Default surface. If the climate can support life, default to grass.
                if (region.Temperature > 0.1f && region.Moisture > 0.1f)
                    c.surface = SurfaceTypes.Grass;
                else //Too cold or dry
                    c.surface = SurfaceTypes.Rock;
                if (region.Climate == ClimateTypes.Desert)
                    c.surface = SurfaceTypes.Sand;
                //Sand is only for coastal regions
                if (low <= 2 && (region.Climate == ClimateTypes.Coast))
                    c.surface = SurfaceTypes.Sand;
                if (low <= 2 && (region.Climate == ClimateTypes.Ocean))
                    c.surface = SurfaceTypes.Sand;
                //Forests are for... forests?
                if (c.detail < 0.75f && c.detail > 0.25f && (region.Climate == ClimateTypes.Forest))
                    c.surface = SurfaceTypes.Forest;
                if (delta >= region.Moisture * 6)
                    c.surface = SurfaceTypes.Dirt;
                if (low <= region.GeoWater && region.Climate != ClimateTypes.Swamp)
                    c.surface = SurfaceTypes.Dirt;
                if (low <= region.GeoWater && region.Climate != ClimateTypes.Swamp)
                    c.surface = SurfaceTypes.DirtDark;
                //The colder it is, the more surface becomes snow, beginning at the lowest points.
                if (region.Temperature < WorldUtils.FREEZING) {
                    var fade = region.Temperature / WorldUtils.FREEZING;
                    if ((1 - c.detail) > fade)
                        c.surface = SurfaceTypes.Snow;
                }

                if (low <= 2.5f && (region.Climate == ClimateTypes.Ocean))
                    c.surface = SurfaceTypes.Sand;
                if (low <= 2.5f && (region.Climate == ClimateTypes.Coast))
                    c.surface = SurfaceTypes.Sand;
                //dirt touched by water is dark
                if (region.Climate != ClimateTypes.Swamp) {
                    if (c.surface == SurfaceTypes.Sand && low <= 0)
                        c.surface = SurfaceTypes.SandDark;
                    if (low <= c.waterLevel)
                        c.surface = SurfaceTypes.DirtDark;
                }

                if (delta > 4 && region.Temperature > 0)
                    c.surface = SurfaceTypes.Rock;
                if ((region.Climate == ClimateTypes.Desert) && c.surface != SurfaceTypes.Rock)
                    c.surface = SurfaceTypes.Sand;
            } else {
                if (c.surface == SurfaceTypes.Grass && this.walk.X > 0 && this.walk.X < PAGE_SIZE - 1 && this.walk.Y > 0 &&
                    this.walk.Y < PAGE_SIZE - 1) {
                    var allGrass = true;
                    for (var xx = -1; xx <= 1; xx++) {
                        if (!allGrass)
                            break;
                        for (var yy = -1; yy <= 1; yy++) {
                            if (this.cells[this.walk.X + xx, this.walk.Y + yy].surface != SurfaceTypes.Grass &&
                                this.cells[this.walk.X + xx, this.walk.Y + yy].surface != SurfaceTypes.GrassEdge) {
                                allGrass = false;
                                break;
                            }
                        }
                    }

                    if (!allGrass)
                        c.surface = SurfaceTypes.GrassEdge;
                }
            }

            this.walk.Walk(PAGE_SIZE, out var rolledOver);
            if (rolledOver)
                this.stage++;
        }

        #endregion
    }
}
